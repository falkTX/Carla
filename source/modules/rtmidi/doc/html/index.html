<HTML>
<HEAD>
<TITLE>The RtMidi Tutorial</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.6.2 -->
<div class="contents">
<h1>The <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> Tutorial </h1><h3 class="version">2.0.1 </h3><center><a class="el" href="index.html#intro">Introduction</a> &nbsp;&nbsp; <a class="el" href="index.html#download">Download</a> &nbsp;&nbsp; <a class="el" href="index.html#start">Getting Started</a> &nbsp;&nbsp; <a class="el" href="index.html#error">Error Handling</a> &nbsp;&nbsp; <a class="el" href="index.html#probing">Probing Ports</a> &nbsp;&nbsp; <a class="el" href="index.html#output">MIDI Output</a> &nbsp;&nbsp; <a class="el" href="index.html#input">MIDI Input</a> &nbsp;&nbsp; <a class="el" href="index.html#virtual">Virtual Ports</a> &nbsp;&nbsp; <a class="el" href="index.html#compiling">Compiling</a> &nbsp;&nbsp; <a class="el" href="index.html#debug">Debugging</a> &nbsp;&nbsp; <a class="el" href="index.html#multi">Using Simultaneous Multiple APIs</a> &nbsp;&nbsp; <a class="el" href="index.html#apinotes">API Notes</a> &nbsp;&nbsp; <a class="el" href="index.html#acknowledge">Acknowledgements</a> &nbsp;&nbsp; <a class="el" href="index.html#license">License</a></center><h2><a class="anchor" id="intro">
Introduction</a></h2>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> is a set of C++ classes (<a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>, <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a> and API-specific classes) that provides a common API (Application Programming Interface) for realtime MIDI input/output across Linux (ALSA &amp; Jack), Macintosh OS X (CoreMidi &amp; Jack), and Windows (Multimedia Library &amp; Kernel Streaming) operating systems. <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> significantly simplifies the process of interacting with computer MIDI hardware and software. It was designed with the following goals:</p>
<ul>
<li>
object oriented C++ design </li>
<li>
simple, common API across all supported platforms </li>
<li>
only two header files and one source file for easy inclusion in programming projects </li>
<li>
MIDI device enumeration </li>
</ul>
<p>Where applicable, multiple API support can be compiled and a particular API specified when creating an RtAudio instance.</p>
<p>MIDI input and output functionality are separated into two classes, <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> and <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a>. Each class instance supports only a single MIDI connection. <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> does not provide timing functionality (i.e., output messages are sent immediately). Input messages are timestamped with delta times in seconds (via a <code>double</code> floating point type). MIDI data is passed to the user as raw bytes using an std::vector&lt;unsigned char&gt;.</p>
<h2><a class="anchor" id="whatsnew">
What's New (Version 2.0)</a></h2>
<p>No incompatable API changes were made in version 2.0, however, support for multiple compiled APIs (where available) was added (see <a class="el" href="index.html#multi">Using Simultaneous Multiple APIs</a>). Other changes include: 1. Added Windows Kernel Streaming support (thanks to Sebastien Alaiwan), though not tested in Visual Studio (and timestamping is not implemented); and 2. Support for the IRIX (SGI) operating system was discontinued.</p>
<h2><a class="anchor" id="download">
Download</a></h2>
<p>Latest Release (26 July 2012): <a href="http://www.music.mcgill.ca/~gary/rtmidi/release/rtmidi-2.0.1.tar.gz">Version 2.0.1</a></p>
<h2><a class="anchor" id="start">
Getting Started</a></h2>
<p>The first thing that must be done when using <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> is to create an instance of the <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> or <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a> subclasses. <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> is an abstract base class, which itself cannot be instantiated. Each default constructor attempts to establish any necessary "connections" with the underlying MIDI system. <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> uses C++ exceptions to report errors, necessitating try/catch blocks around many member functions. An <a class="el" href="classRtError.html" title="Exception handling class for RtAudio &amp; RtMidi.">RtError</a> can be thrown during instantiation in some circumstances. A warning message may also be reported if no MIDI devices are found during instantiation. The <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> classes have been designed to work with "hot pluggable" or virtual (software) MIDI devices, making it possible to connect to MIDI devices that may not have been present when the classes were instantiated. The following code example demonstrates default object construction and destruction:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="RtMidi_8h.html">RtMidi.h</a>&quot;</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> *midiin = 0;

  <span class="comment">// RtMidiIn constructor</span>
  <span class="keywordflow">try</span> {
    midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error) {
    <span class="comment">// Handle the exception here</span>
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
  }

  <span class="comment">// Clean up</span>
  <span class="keyword">delete</span> midiin;
}
</pre></div><p>Obviously, this example doesn't demonstrate any of the real functionality of <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a>. However, all uses of <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> must begin with construction and must end with class destruction. Further, it is necessary that all class methods that can throw a C++ exception be called within a try/catch block.</p>
<h2><a class="anchor" id="error">
Error Handling</a></h2>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> uses a C++ exception handler called <a class="el" href="classRtError.html" title="Exception handling class for RtAudio &amp; RtMidi.">RtError</a>, which is declared and defined in <a class="el" href="RtError_8h_source.html">RtError.h</a>. The <a class="el" href="classRtError.html" title="Exception handling class for RtAudio &amp; RtMidi.">RtError</a> class is quite simple but it does allow errors to be "caught" by <a class="el" href="classRtError.html#ab04667aae01bffc354a9ac6bda6903ac" title="Defined RtError types.">RtError::Type</a>. Many <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> methods can "throw" an <a class="el" href="classRtError.html" title="Exception handling class for RtAudio &amp; RtMidi.">RtError</a>, most typically if a driver error occurs or an invalid function argument is specified. There are a number of cases within <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> where warning messages may be displayed but an exception is not thrown. There is a protected <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> method, error(), that can be modified to globally control how these messages are handled and reported. By default, error messages are not automatically displayed in <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> unless the preprocessor definition __RTMIDI_DEBUG__ is defined during compilation. Messages associated with caught exceptions can be displayed with, for example, the <a class="el" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">RtError::printMessage()</a> function.</p>
<h2><a class="anchor" id="probing">
Probing Ports</a></h2>
<p>A programmer may wish to query the available MIDI ports before deciding which to use. The following example outlines how this can be done.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// midiprobe.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtMidi_8h.html">RtMidi.h</a>&quot;</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>  *midiin = 0;
  <a class="code" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a> *midiout = 0;

  <span class="comment">// RtMidiIn constructor</span>
  <span class="keywordflow">try</span> {
    midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    exit( EXIT_FAILURE );
  }

  <span class="comment">// Check inputs.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a62b1b38aa8e5f11cd66f03d59228f4e4" title="Return the number of available MIDI input ports.">getPortCount</a>();
  std::cout &lt;&lt; <span class="stringliteral">&quot;\nThere are &quot;</span> &lt;&lt; nPorts &lt;&lt; <span class="stringliteral">&quot; MIDI input sources available.\n&quot;</span>;
  std::string portName;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nPorts; i++ ) {
    <span class="keywordflow">try</span> {
      portName = midiin-&gt;<a class="code" href="classRtMidiIn.html#af2961fff09fa01a3d5bc0f0c5a042aaf" title="Return a string identifier for the specified MIDI input port number.">getPortName</a>(i);
    }
    <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
      error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
      <span class="keywordflow">goto</span> cleanup;
    }
    std::cout &lt;&lt; <span class="stringliteral">&quot;  Input Port #&quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; portName &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
  }

  <span class="comment">// RtMidiOut constructor</span>
  <span class="keywordflow">try</span> {
    midiout = <span class="keyword">new</span> <a class="code" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    exit( EXIT_FAILURE );
  }

  <span class="comment">// Check outputs.</span>
  nPorts = midiout-&gt;<a class="code" href="classRtMidiOut.html#a0c4d662e1c398ddf35a2dbaf66f50976" title="Return the number of available MIDI output ports.">getPortCount</a>();
  std::cout &lt;&lt; <span class="stringliteral">&quot;\nThere are &quot;</span> &lt;&lt; nPorts &lt;&lt; <span class="stringliteral">&quot; MIDI output ports available.\n&quot;</span>;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nPorts; i++ ) {
    <span class="keywordflow">try</span> {
      portName = midiout-&gt;<a class="code" href="classRtMidiOut.html#acc4ae0ab71a49ae7629075d5a9cd837c" title="Return a string identifier for the specified MIDI port type and number.">getPortName</a>(i);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error) {
      error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
      <span class="keywordflow">goto</span> cleanup;
    }
    std::cout &lt;&lt; <span class="stringliteral">&quot;  Output Port #&quot;</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; portName &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
  }
  std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;
  <span class="keyword">delete</span> midiout;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="output">
MIDI Output</a></h2>
<p>The <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a> class provides simple functionality to immediately send messages over a MIDI connection. No timing functionality is provided.</p>
<p>In the following example, we omit necessary error checking and details regarding OS-dependent sleep functions. For a complete example, see the <code>midiout.cpp</code> program in the <code>tests</code> directory.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// midiout.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtMidi_8h.html">RtMidi.h</a>&quot;</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a> *midiout = <span class="keyword">new</span> <a class="code" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a>();
  std::vector&lt;unsigned char&gt; message;

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiout-&gt;<a class="code" href="classRtMidiOut.html#a0c4d662e1c398ddf35a2dbaf66f50976" title="Return the number of available MIDI output ports.">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;No ports available!\n&quot;</span>;
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// Open first available port.</span>
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a1b280d67317cd473a8816aeb2fe6c186" title="Open a MIDI output connection.">openPort</a>( 0 );

  <span class="comment">// Send out a series of MIDI messages.</span>

  <span class="comment">// Program change: 192, 5</span>
  message.push_back( 192 );
  message.push_back( 5 );
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a0bd8972ef8ac4e8d37ccc4b5d51c2eb3" title="Immediately send a single message out an open MIDI output port.">sendMessage</a>( &amp;message );

  <span class="comment">// Control Change: 176, 7, 100 (volume)</span>
  message[0] = 176;
  message[1] = 7;
  message.push_back( 100 );
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a0bd8972ef8ac4e8d37ccc4b5d51c2eb3" title="Immediately send a single message out an open MIDI output port.">sendMessage</a>( &amp;message );

  <span class="comment">// Note On: 144, 64, 90</span>
  message[0] = 144;
  message[1] = 64;
  message[2] = 90;
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a0bd8972ef8ac4e8d37ccc4b5d51c2eb3" title="Immediately send a single message out an open MIDI output port.">sendMessage</a>( &amp;message );

  SLEEP( 500 ); <span class="comment">// Platform-dependent ... see example in tests directory.</span>

  <span class="comment">// Note Off: 128, 64, 40</span>
  message[0] = 128;
  message[1] = 64;
  message[2] = 40;
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a0bd8972ef8ac4e8d37ccc4b5d51c2eb3" title="Immediately send a single message out an open MIDI output port.">sendMessage</a>( &amp;message );

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiout;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="input">
MIDI Input</a></h2>
<p>The <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> class uses an internal callback function or thread to receive incoming MIDI messages from a port or device. These messages are then either queued and read by the user via calls to the <a class="el" href="classRtMidiIn.html#a1ba10ecd276b30a8579c7d60a9c890eb" title="Fill the user-provided vector with the data bytes for the next available MIDI message...">RtMidiIn::getMessage()</a> function or immediately passed to a user-specified callback function (which must be "registered" using the <a class="el" href="classRtMidiIn.html#a7590563461c7467608a4b3806406b32d" title="Set a callback function to be invoked for incoming MIDI messages.">RtMidiIn::setCallback()</a> function). We'll provide examples of both usages.</p>
<p>The <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> class provides the <a class="el" href="classRtMidiIn.html#af9507125aaa42276ccc01df576fc3533" title="Specify whether certain MIDI message types should be queued or ignored during input...">RtMidiIn::ignoreTypes()</a> function to specify that certain MIDI message types be ignored. By default, sysem exclusive, timing, and active sensing messages are ignored.</p>
<h3><a class="anchor" id="qmidiin">
Queued MIDI Input</a></h3>
<p>The <a class="el" href="classRtMidiIn.html#a1ba10ecd276b30a8579c7d60a9c890eb" title="Fill the user-provided vector with the data bytes for the next available MIDI message...">RtMidiIn::getMessage()</a> function does not block. If a MIDI message is available in the queue, it is copied to the user-provided <code>std::vector&lt;unsigned char&gt;</code> container. When no MIDI message is available, the function returns an empty container. The default maximum MIDI queue size is 1024 messages. This value may be modified with the RtMidiIn::setQueueSizeLimit() function. If the maximum queue size limit is reached, subsequent incoming MIDI messages are discarded until the queue size is reduced.</p>
<p>In the following example, we omit some necessary error checking and details regarding OS-dependent sleep functions. For a more complete example, see the <code>qmidiin.cpp</code> program in the <code>tests</code> directory.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// qmidiin.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtMidi_8h.html">RtMidi.h</a>&quot;</span>

<span class="keywordtype">bool</span> done;
<span class="keyword">static</span> <span class="keywordtype">void</span> finish(<span class="keywordtype">int</span> ignore){ done = <span class="keyword">true</span>; }

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> *midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>();
  std::vector&lt;unsigned char&gt; message;
  <span class="keywordtype">int</span> nBytes, i;
  <span class="keywordtype">double</span> stamp;

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a62b1b38aa8e5f11cd66f03d59228f4e4" title="Return the number of available MIDI input ports.">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;No ports available!\n&quot;</span>;
    <span class="keywordflow">goto</span> cleanup;
  }
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a39df8f81a22f729a9904707dde487d2c" title="Open a MIDI input connection.">openPort</a>( 0 );

  <span class="comment">// Don&#39;t ignore sysex, timing, or active sensing messages.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#af9507125aaa42276ccc01df576fc3533" title="Specify whether certain MIDI message types should be queued or ignored during input...">ignoreTypes</a>( <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> );

  <span class="comment">// Install an interrupt handler function.</span>
  done = <span class="keyword">false</span>;
  (void) signal(SIGINT, finish);

  <span class="comment">// Periodically check input queue.</span>
  std::cout &lt;&lt; <span class="stringliteral">&quot;Reading MIDI from port ... quit with Ctrl-C.\n&quot;</span>;
  <span class="keywordflow">while</span> ( !done ) {
    stamp = midiin-&gt;<a class="code" href="classRtMidiIn.html#a1ba10ecd276b30a8579c7d60a9c890eb" title="Fill the user-provided vector with the data bytes for the next available MIDI message...">getMessage</a>( &amp;message );
    nBytes = message.size();
    <span class="keywordflow">for</span> ( i=0; i&lt;nBytes; i++ )
      std::cout &lt;&lt; <span class="stringliteral">&quot;Byte &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; (<span class="keywordtype">int</span>)message[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
    <span class="keywordflow">if</span> ( nBytes &gt; 0 )
      std::cout &lt;&lt; <span class="stringliteral">&quot;stamp = &quot;</span> &lt;&lt; stamp &lt;&lt; std::endl;

    <span class="comment">// Sleep for 10 milliseconds ... platform-dependent.</span>
    SLEEP( 10 );
  }

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" id="cmidiin">
MIDI Input with User Callback</a></h3>
<p>When set, a user-provided callback function will be invoked after the input of a complete MIDI message. It is possible to provide a pointer to user data that can be accessed in the callback function (not shown here). It is necessary to set the callback function immediately after opening the port to avoid having incoming messages written to the queue (which is not emptied when a callback function is set). If you are worried about this happening, you can check the queue using the RtMidi::getMessage() function to verify it is empty (after the callback function is set).</p>
<p>In the following example, we omit some necessary error checking. For a more complete example, see the <code>cmidiin.cpp</code> program in the <code>tests</code> directory.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// cmidiin.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtMidi_8h.html">RtMidi.h</a>&quot;</span>

<span class="keywordtype">void</span> mycallback( <span class="keywordtype">double</span> deltatime, std::vector&lt; unsigned char &gt; *message, <span class="keywordtype">void</span> *userData )
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBytes = message-&gt;size();
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nBytes; i++ )
    std::cout &lt;&lt; <span class="stringliteral">&quot;Byte &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; (<span class="keywordtype">int</span>)message-&gt;at(i) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
  <span class="keywordflow">if</span> ( nBytes &gt; 0 )
    std::cout &lt;&lt; <span class="stringliteral">&quot;stamp = &quot;</span> &lt;&lt; deltatime &lt;&lt; std::endl;
}

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> *midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a>();

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a62b1b38aa8e5f11cd66f03d59228f4e4" title="Return the number of available MIDI input ports.">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">&quot;No ports available!\n&quot;</span>;
    <span class="keywordflow">goto</span> cleanup;
  }

  midiin-&gt;<a class="code" href="classRtMidiIn.html#a39df8f81a22f729a9904707dde487d2c" title="Open a MIDI input connection.">openPort</a>( 0 );

  <span class="comment">// Set our callback function.  This should be done immediately after</span>
  <span class="comment">// opening the port to avoid having incoming messages written to the</span>
  <span class="comment">// queue.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a7590563461c7467608a4b3806406b32d" title="Set a callback function to be invoked for incoming MIDI messages.">setCallback</a>( &amp;mycallback );

  <span class="comment">// Don&#39;t ignore sysex, timing, or active sensing messages.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#af9507125aaa42276ccc01df576fc3533" title="Specify whether certain MIDI message types should be queued or ignored during input...">ignoreTypes</a>( <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> );

  std::cout &lt;&lt; <span class="stringliteral">&quot;\nReading MIDI input ... press &lt;enter&gt; to quit.\n&quot;</span>;
  <span class="keywordtype">char</span> input;
  std::cin.get(input);

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="virtual">
Virtual Ports</a></h2>
<p>The Linux ALSA and Macintosh CoreMIDI APIs allow for the establishment of virtual input and output MIDI ports to which other software clients can connect. <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> incorporates this functionality with the <a class="el" href="classRtMidiIn.html#a245261b3f12ce727faed18fcfeef18c2" title="Create a virtual input port, with optional name, to allow software connections (OS...">RtMidiIn::openVirtualPort()</a> and <a class="el" href="classRtMidiOut.html#a47068e1c076d91fd89587c0ccdeddc7a" title="Create a virtual output port, with optional name, to allow software connections (OS...">RtMidiOut::openVirtualPort()</a> functions. Any messages sent with the <a class="el" href="classRtMidiOut.html#a0bd8972ef8ac4e8d37ccc4b5d51c2eb3" title="Immediately send a single message out an open MIDI output port.">RtMidiOut::sendMessage()</a> function will also be transmitted through an open virtual output port. If a virtual input port is open and a user callback function is set, the callback function will be invoked when messages arrive via that port. If a callback function is not set, the user must poll the input queue to check whether messages have arrived. No notification is provided for the establishment of a client connection via a virtual port.</p>
<h2><a class="anchor" id="compiling">
Compiling</a></h2>
<p>In order to compile <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> for a specific OS and API, it is necessary to supply the appropriate preprocessor definition and library within the compiler statement: </p>
<table class="doxtable" border="2" cols="5" width="100%">
<tr bgcolor="beige">
<td width="5%"><b>OS:</b> </td><td width="5%"><b>MIDI API:</b> </td><td width="5%"><b>Preprocessor Definition:</b> </td><td width="5%"><b>Library or Framework:</b> </td><td><b>Example Compiler Statement:</b>  </td></tr>
<tr>
<td>Linux </td><td>ALSA Sequencer </td><td>__LINUX_ALSA__ </td><td><code>asound, pthread</code> </td><td><code>g++ -Wall -D__LINUX_ALSA__ -o midiprobe midiprobe.cpp RtMidi.cpp -lasound -lpthread</code>  </td></tr>
<tr>
<td>Linux or Mac </td><td>Jack MIDI </td><td>__UNIX_JACK__ </td><td><code>jack</code> </td><td><code>g++ -Wall -D__UNIX_JACK__ -o midiprobe midiprobe.cpp RtMidi.cpp -ljack</code>  </td></tr>
<tr>
<td>Macintosh OS X </td><td>CoreMidi </td><td>__MACOSX_CORE__ </td><td><code>CoreMidi, CoreAudio, CoreFoundation</code> </td><td><code>g++ -Wall -D__MACOSX_CORE__ -o midiprobe midiprobe.cpp RtMidi.cpp -framework CoreMIDI -framework CoreAudio -framework CoreFoundation</code>  </td></tr>
<tr>
<td>Windows </td><td>Multimedia Library </td><td>__WINDOWS_MM__ </td><td><code>winmm.lib, multithreaded</code> </td><td><em>compiler specific</em>  </td></tr>
<tr>
<td>Windows </td><td>Kernel Streaming </td><td>__WINDOWS_KS__ </td><td><code>ks.h, ksmedia.h, setupapi.lib, ksuser.lib, multithreaded</code> </td><td><em>compiler specific</em>  </td></tr>
</table>
<p>The example compiler statements above could be used to compile the <code>midiprobe.cpp</code> example file, assuming that <code>midiprobe.cpp</code>, <code><a class="el" href="RtMidi_8h.html">RtMidi.h</a></code>, <code><a class="el" href="RtError_8h_source.html">RtError.h</a></code>, and <code>RtMidi.cpp</code> all exist in the same directory.</p>
<h2><a class="anchor" id="debug">
Debugging</a></h2>
<p>If you are having problems getting <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> to run on your system, try passing the preprocessor definition <code>__RTMIDI_DEBUG__</code> to the compiler (or define it in <a class="el" href="RtMidi_8h.html">RtMidi.h</a>). A variety of warning messages will be displayed that may help in determining the problem. Also try using the programs included in the <code>test</code> directory. The program <code>midiprobe</code> displays the queried capabilities of all MIDI ports found.</p>
<h2><a class="anchor" id="multi">
Using Simultaneous Multiple APIs</a></h2>
<p>Support for each MIDI API is encapsulated in specific <a class="el" href="classMidiInApi.html">MidiInApi</a> or <a class="el" href="classMidiOutApi.html">MidiOutApi</a> subclasses, making it possible to compile and instantiate multiple API-specific subclasses on a given operating system. For example, one can compile both the CoreMIDI and Jack support on the OS-X operating system by providing the appropriate preprocessor definitions for each. In a run-time situation, one might first attempt to determine whether any Jack ports are available. This can be done by specifying the api argument <a class="el" href="classRtMidi.html#aac66af04a85fe5c5f07c360574a19406a1f59daf3120f47c0ae3891773112ddfa">RtMidi::UNIX_JACK</a> when attempting to create an instance of <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> or <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a>. If no available ports are found, then an instance of <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> with the api argument <a class="el" href="classRtMidi.html#aac66af04a85fe5c5f07c360574a19406a3f41293f89467641484fbd54c4530908">RtMidi::MACOSX_CORE</a> can be created. Alternately, if no api argument is specified, <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> will first look for CoreMIDI ports and if none are found, then Jack ports (in linux, the search order is ALSA and then Jack; in windows, the search order is WinMM and then WinKS). In theory, it should also be possible to have separate instances of <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> open at the same time with different underlying API support, though this has not been tested.</p>
<p>The static function <a class="el" href="classRtMidi.html#a025fa339486c9a34b26ec707aa2944ce" title="A static function to determine the available compiled MIDI APIs.">RtMidi::getCompiledApi()</a> is provided to determine the available compiled API support. The function RtMidi::getCurrentApi() indicates the API selected for a given <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> instance.</p>
<h2><a class="anchor" id="apinotes">
API Notes</a></h2>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> is designed to provide a common API across the various supported operating systems and audio libraries. Despite that, some issues should be mentioned with regard to each.</p>
<h3><a class="anchor" id="linux">
Linux:</a></h3>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> for Linux was developed using the Fedora distribution. Two different MIDI APIs are supported on Linux platforms: <a href="http://www.alsa-project.org/">ALSA</a> and <a href="http://jackit.sourceforge.net/">Jack</a>. A decision was made to not include support for the OSS API because the OSS API provides such limited functionality and because <a href="http://www.alsa-project.org/">ALSA</a> support is now incorporated in the Linux kernel. The ALSA sequencer and Jack APIs allows for virtual software input and output ports.</p>
<h3><a class="anchor" id="macosx">
Macintosh OS X (CoreAudio):</a></h3>
<p>The Apple CoreMidi API allows for the establishment of virtual input and output ports to which other software applications can connect.</p>
<p>The <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> Jack support can be compiled on Macintosh OS-X systems, as well as in Linux.</p>
<h3><a class="anchor" id="windowsds">
Windows (Multimedia Library):</a></h3>
<p>The <code>configure</code> script provides support for the MinGW compiler.</p>
<p>The Windows Multimedia library MIDI calls used in <a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> do not make use of streaming functionality. Incoming system exclusive messages read by <a class="el" href="classRtMidiIn.html" title="A realtime MIDI input class.">RtMidiIn</a> are limited to a length as defined by the preprocessor definition RT_SYSEX_BUFFER_SIZE (set in RtMidi.cpp). The default value is 1024. There is no such limit for outgoing sysex messages via <a class="el" href="classRtMidiOut.html" title="A realtime MIDI output class.">RtMidiOut</a>.</p>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a> was originally developed with Visual C++ version 6.0.</p>
<p>The <code>configure</code> script provides support for the MinGW compiler.</p>
<h2><a class="anchor" id="acknowledge">
Acknowledgements</a></h2>
<p>Many thanks to the following people for providing bug fixes and improvements: </p>
<ul>
<li>
Sebastien Alaiwan (Jack memory leaks, Windows kernel streaming) </li>
<li>
Jean-Baptiste Berruchon (Windows sysex code) </li>
<li>
Pedro Lopez-Cabanillas (ALSA sequencer API, client naming) </li>
<li>
Jason Champion (MSW project file for library build) </li>
<li>
Eduardo Coutinho (Windows device names) </li>
<li>
Paul Dean (increment optimization) </li>
<li>
Luc Deschenaux (sysex issues) </li>
<li>
John Dey (OS-X timestamps) </li>
<li>
Christoph Eckert (ALSA sysex fixes) </li>
<li>
Martin Koegler (various fixes) </li>
<li>
Immanuel Litzroth (OS-X sysex fix) </li>
<li>
Jon McCormack (Snow Leopard updates) </li>
<li>
Axel Schmidt (client naming) </li>
<li>
Alexander Svetalkin (Jack MIDI) </li>
<li>
Casey Tucker (OS-X driver information, sysex sending) </li>
<li>
Bastiaan Verreijt (Windows sysex multi-buffer code) </li>
<li>
Dan Wilcox </li>
</ul>
<h2><a class="anchor" id="license">
License</a></h2>
<p><a class="el" href="classRtMidi.html" title="An abstract base class for realtime MIDI input/output.">RtMidi</a>: realtime MIDI i/o C++ classes<br/>
 Copyright (c) 2003-2012 Gary P. Scavone</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>Any person wishing to distribute modifications to the Software is asked to send the modifications to the original developer so that they can be incorporated into the canonical version. This is, however, not a binding provision of this license.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div>
<HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2003-2012 Gary P. Scavone, McGill University. All Rights Reserved.<br>
  Maintained by Gary P. Scavone, gary at music.mcgill.ca</td></tr>
</table>

</BODY>
</HTML>
